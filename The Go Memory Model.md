# Go内存模型

[介绍](#介绍)
[忠告](#忠告)
[先行发生原则](#先行发生原则)
[同步](#同步)
&nbsp;&nbsp;&nbsp;&nbsp;[初始化](#初始化)
&nbsp;&nbsp;&nbsp;&nbsp;[Go协程的创建](#Go协程的创建)
&nbsp;&nbsp;&nbsp;&nbsp;[Go协程的销毁](#Go协程的销毁)
&nbsp;&nbsp;&nbsp;&nbsp;[香奈儿通信](#香奈儿通信)
&nbsp;&nbsp;&nbsp;&nbsp;[锁](#锁)
&nbsp;&nbsp;&nbsp;&nbsp;[Once](#Once)
[错误的同步](#错误的同步)

## 介绍

Go内存模型定义了在什么样的条件下能够保证一个Go协程可以观察到另一个Go协程对同一变量的修改。

## 忠告

如果程序要修改可能被多个Go协程访问的数据，那么就必须要对访问做串行化处理。

要保护数据，做串行化访问，可以用香奈儿或者其他的同步原语，比如[sync](#)和[sync/atomic](#sync/atomic)中提供的那些玩意儿。

如果你想通过本文的学习来了解你的程序，那你想多了。

别自作聪明。

（网上查了一下，最后这点翻译的五花八门，我也不确定是不是该这么翻译。）

## 先行发生原则

在一个Go协程内部，读写操作必须要表现得跟代码定义的顺序一致。也就是说编译器和处理器只能在不影响语言规范定义的顺序行为时，才能调整一个Go协程内部的读写操作顺序。因为这种重排序的存在，导致一个Go协程内观察到的执行顺序可能跟另一个Go协程感受到的不一样。比如一个Go协程执行a = 1; b = 2，另一个Go协程可能先观察到b的更新，然后才是a的更新。

