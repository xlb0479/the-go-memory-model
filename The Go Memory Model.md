# Go内存模型

[介绍](#介绍)
[忠告](#忠告)
[先行发生原则](#先行发生原则)
[同步](#同步)
&nbsp;&nbsp;&nbsp;&nbsp;[初始化](#初始化)
&nbsp;&nbsp;&nbsp;&nbsp;[Go协程的创建](#Go协程的创建)
&nbsp;&nbsp;&nbsp;&nbsp;[Go协程的销毁](#Go协程的销毁)
&nbsp;&nbsp;&nbsp;&nbsp;[香奈儿通信](#香奈儿通信)
&nbsp;&nbsp;&nbsp;&nbsp;[锁](#锁)
&nbsp;&nbsp;&nbsp;&nbsp;[Once](#Once)
[错误的同步](#错误的同步)

## 介绍

Go内存模型定义了在什么样的条件下能够保证一个Go协程可以观察到另一个Go协程对同一变量的修改。

## 忠告

如果程序要修改可能被多个Go协程访问的数据，那么就必须要对访问做串行化处理。

要保护数据，做串行化访问，可以用香奈儿或者其他的同步原语，比如[sync](#)和[sync/atomic](#sync/atomic)中提供的那些玩意儿。

如果你想通过本文的学习来了解你的程序，那你想多了。

别自作聪明。

（网上查了一下，最后这点翻译的五花八门，我也不确定是不是该这么翻译。）

## 先行发生原则

在一个Go协程内部，读写操作必须要表现得跟代码定义的顺序一致。也就是说编译器和处理器只能在不影响语言规范定义的行为顺序时，才能调整一个Go协程内部的读写操作顺序。因为这种重排序的存在，导致一个Go协程内观察到的执行顺序可能跟另一个Go协程感受到的不一样。比如一个Go协程执行a = 1; b = 2，另一个Go协程可能先观察到b的更新，然后才是a的更新。

为了明确读写行为准则，我们搞了一套*先行发生（happens before）*原则，这是Go程序中关于内存操作执行顺序的部分有序原则。如果事件e<sub>1</sub>先行发生于e<sub>2</sub>，那么e<sub>2</sub>就后行发生于e<sub>1</sub>。并且，如果e<sub>1</sub>对于e<sub>2</sub>既非先行发生也非后行发生，则我们说e<sub>1</sub>和e<sub>2</sub>是并发的。

*在一个Go协程内，先行发生的顺序即程序所表达的顺序。*

当以下条件成立时，对变量v的读操作*r*，*允许*观察到对v的写操作*w*：

1. *r*没有先行发生于*w*。
2. 不存在另一个对v的写操作*w'*，它后行发生于*w*但先行发生于*r*。

要想保证对变量v的读操作*r*观察到一个特定的对v的写操作*w*，就要保证*w*是*r*唯一能够被允许观察到的写操作。也就是说，当以下条件成立时，*r*能够*确保*观察到*w*：

1. *w*先行发生于*r*。
2. 对于共享变量v的其他写操作全都先行发生于*w*或者后行发生于*r*。

这组条件比上一组更严格；它要求不能有其他的写操作和*w*或*r*并发。

在一个Go协程内，不存在并发，此时两种定义是等价的：读操作*r*观察到对变量v最近一次写操作*w*所写入的值。当多个Go协程访问共享变量v，它们必须要基于同步事件来建立起先行发生原则，保证读操作能够观察到所需的写操作。

在内存模型中，对变量v使用对应类型零值进行初始化，被视为一次写操作。

如果读写的值大于一个机器字（word），则以无法预知的顺序进行多次机器字长（machine-word-sized）操作。

## 同步

### 初始化

程序初始化是在单一Go协程内运行的，但这个Go协程也可能创建其他Go协程，它们就并发了。